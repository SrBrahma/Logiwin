+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+
Logiwin Open Project
Version 1.1.0  - xx/05/2016

Starting date of this documentation: 28/02/15 (Like a year before publishing it!)

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                                   # Index #
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- 
    Also try Ctrl+f

    1. Introduction
    2. Basic Explanations
    3. Patch notes
    4. Future updates list
    5. Downloads links
    6. Advanced Explanations
    7. Console Special Codes
    8. Clock Script
    9. Instruction Set Descriptions
    A. Instruction Set List
    B. Credits, special thanks and contact

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
1.                               Introduction
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Hi!


    Hello, fellow reader! This is a hobby of mine, that I have been working for some years; maybe 3, maybe 4 (EDIT 1.1.0: Now maybe 6)
    This circuit is my interpretation of a computer, but it doesn't follow strictly any existing system.


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
2.                            Basic Explanations
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 A better introduction!


    4.1)  My main idea in this project is to be an easily modified circuit by any one (with some knowledge), and you should do it. I really want a community
 for it, with everybody working together, and this includes Programmers, Designers, people who knows how to deal with sound
 and music (sound for it!), JAR libraries modders (AltruismAndCake, the first one!) and finnaly the Eletronics ones.
    4.2)  I didn't intended to make the project look like a real CPU, computer, etc. This is my interpretation of what it should be to work 
 in a single-clock and to have the fastest simulation speed as possible. When I started it, I didn't have specific knowledges about programmation, engineering, etc.
 Some stuff can work similiarly to real life. If you have better ideas for names of anything, tell me so I can correct it and make more 
 common user-friendly. Most instructions I made intended to look like Assembly but there's are some differencer.
    4.3)  It is free the alteration and the sharing of this project by anyone, but the credits must stay in my name. 
    4.5)  Most sub-circuits have explanations inside them, to help the modders and curious ones.
    4.6)  When editing or analysing this circuit, remember the propagation delays in the circuits. Some stuff are ugly to bypass them.
    4.7)  Contact me by e-mail or in the Reddit. The information about contact is on the end of this documentation. If you share 
 and/or modify this project, tell me please! I will be happy to know that this hobby got it fans :)
    4.8)  The connections in this circuit can look strange, but was kinda intentional. Looks like the fewer wire nodes, the faster the simulation frequency.
    4.9)  Many informations you may need are in this documentation. However, some of the functionalities and explanations may be missing here. Contact me 
 for further help, and so I can upgrade this doc.
    4.a)  Also, there can be some misleading informations in this document, as I change stuff on the project all the time and I forget to update they info here.     
 If anything is unclear or wrong; as always, contact me to fix it.
    4.b)  Looking for basic help? So you should google: Hexadecimal, Logic gates, Machine Code, CPU architetures,
 Instruction sets, Assembly, etc.
    4.c)  Feeling bored of learning by reading? I do reccomend these games: "KOHCTPYKTOP", "TIS-100", "SHENZHEN I/O" (Yeah, I do love Zach games!), "Silicon Zeroes".
    4.d)


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
3.                                Patch notes
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 So, what's the news?


    v1.1.0 - xx/06/16 Yeah, this update took some really big time. Everytime I find a big problem here I just
get real bored just by opening Logisim and insta close it.


    New:   Bin to BCD decoder intruction.
        LIFO added, with Push, Pop, Call and Return instructions.
        Random instruction.
        Keyboard added.
        Added and changed a lot of stuff in this Readme.
        Store Current Address (SCA) instruction.
        Increase and Decrease (INC & DEC) instructions.  
        Joystick added
        Renamed MOV to ACC, as MOV was very ambiguos.
        It now have 2 clocks instead of one (read 7.3).
        The main RAM controller is now inside the CPU, got some performance buff.
        Removed all the delayers from the Console, as I added a new Clock.
        Changed TXT intruction code.
        General perfomance boosts. Unfortunatelly, with all the new stuff, the performance has decayed.
        General changes.
        

    Fixes: Fixed CMP clearing Acc. 
        Fixed conditional jumps.
        Some general stuff.

   v1.0.5 - 03/03/16 Added SWP and ERS instructions. JMP instructions can now jump to values stored in Address. Changed text 7-bit to 8-bit
(easier to deal with). Some general changes. Changed some stuff in this documentation. Added a Mario in a screen for fun (and for some research).
Great times are coming!

   v1.0.1 - 25/02/16 Fixed a small problem, NOT and NEG weren't connected on ALU.    

   v1.0.0 - 25/02/16 Almost an year since the beggining of this documentation on notepad++ (but now you should open it on normal notepad for the
formatation). Time flies! The first public Logiwin version, still very alpha, but I wanted to share the most soon as possible! Most don't work yet,
but it is possible to have some fun just with the memory and console on the main circuit.


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
4.                            Future updates list
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Hey, hey! What's coming next?

      Mouse-Pad mod compatibility (when it exists!) - Ever wanted to touch you screen?
      Instructions to use the Output 2 of ALU and Clear ALU Flag.
      Sound (Waiting for a mod!)
      Floating Point System (This will take time)
      Programs, as Notepad, programs editor, Paint brush style program, etc etc. Already writing some.
      An Operating System. Maybe I will call it Logiwin OS. Looks badass.


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
5.                              Downloads links
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Here's what you need to have it running. Be sure to read 5.2. 

   5.1)  Logisim, the simulation program (I recommend this unnoficial version, but the original can be found on google). I simple don't like the another 
unnoficial Logisim version, the Logisim Evolution, also, it won't work with AtruismAndCake mods (he only would need to rename his
the RAM, but i won't ask him to do it, just because I won't use the Evolution), so the Logiwin won't load. So or you use the official or this one:
   NOTE: Here, to make the mods work with this unnoficial version, i had to first run the official Logisim and load them. Otherwise the mods won't load properly.
   http:www.cs.cornell.edu/courses/cs3410/2015sp/logisim-2.7.2-cs3410-20140215.jar

   5.2)  The mods (you MUST download this one, instructions on how to install on the page, but I assure you it's pretty easy!): 
   https:www.reddit.com/r/logisim/comments/46lrow/modding_new_mods_folder/


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
6.                           Technical Informations
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    6.1)  "X" in this documentation can be even 0 or 1, sometimes changing it functionallity.
    6.2)  NEVER EVER write anything in Address 0x000000, it WILL get buggy. Some instructions propagations delays will use it.
        Just avoid this bad Address and everything is gonna be alright!  
    6.3)  0xxx xxx1:
        First bit = 1 (The last form left to right, the 1st bit)
        Last bit = 0  (The first from left to right, the 8th bit)
    6.4)  You can directly only use 24-bit data (like ADD #0xffffff), but it is possible to do stuff like this:
      Have the value already written on memory, and access it when you want
                      Or if you don't have it written
                ACC #0xffffff (load on accumulator the last 24 bits.)
                SHL #0x000008 (shift left acc for 8 units)
                ADD #0x0000aa (add the first 8 bits)
      Now you will have a full 32-bit data on the accumulator, and can do this
                STO #0xXXXXXX (store this value at any place you want)
      And finally, when you want
                ADD 0xXXXXXX  (will use the value you stored, that will stands for 0xffffffaa (32-bit sized))
    6.5)  "ALU Flag" is like a Carry Flag, but indicates if there is carry out from sum or multiplication, burrow out from substract and remain from divide.
    6.6)  "Out2" from ALU outputs the remain from divide or carry out from multiplication. I will give it an instruction later.
    6.7)  Address = 24bits
        0000 0000 0000 0000 0000 0000
        23-24bits for determinating the storage device (leftist ones)
         = 00 is for the non-volatile memory, a SSD-like memory.
         = 01 is for the volatile memory, a RAM-like memory.
         = The other values are for now unused, maybe in the future new storage devices will be added.
    6.8)  Deppending on your real hardware, you will get a faster or slower simulation frequency (so will be the Instructions per Second).
 
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
7.                          Console Special Codes
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Specials ASCII codes for the Console, the screen which outputs text.  

    7.1)  Copied from the Library Reference from Logisim: 
        "The only supported control sequences are: backspace (ASCII 8), which deletes the last character in the final row, unless the final row is already empty; 
        newline (ASCII 10), which moves the cursor to the beginning of the following line, scrolling if necessary;
        and form-feed (ASCII 12, typed as control-L), which clears the screen."

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
8.                             Clock Script
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 What happens in each part of the CPU clock cycle. Remember this concept: 
         _____       ____        1 (High)
   _____/     \_____/    \_____  0 (Low) 
   (   8.1   8.2   8.1   8.2)

    8.1)  Rising Edge
        >Program Counter Increases (or jump if instructed to).
        >If instructed, data is be stored in the Memory, or in the Accumulator or in the LIFO.
        >The instruction register is cleared (to avoid propagation issues).
        
    8.2) Falling Edge
        >Instruction is loaded.
        >Some instructions are executed.
        
    8.3)  Since v1.1.0, circuit have 2 clocks, the CPU clock and the new one.
        CPU Clock -> Now by default have a Low Duration of 3 (you can change to 5,7,9...), but still have a High Duration of 1. (Read 1/3 timing)
        It don't make the circuit work slower (for having a higher delay between clocks), as when you increase the delay, the simulation frequency increases.
        Ex: Before, when the CPU clock was 1/1, when the Logiwin CPU was 100% on load, the Logisim simulation was ~1KHz (~500 Instructions per Second).
        Now with 1/3 for example, in heavy usage (same circunstances), frequency displayed is on ~2KHz (still ~500 ips)
        For the curious ones, on 1/5 Clock, the frequency was ~3KHz (Still ~500ips!).
        As you see, this change (made to fix some issues) won't slow down the Logiwin CPU. 
        New one -> The another Clock is a 1/1 timing clock, for general porpouses (like console).
 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
9.                        Instruction Set Explained                     
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Don't know how a instruction works, or what it do? Here you can learn about it.


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   9.1   General
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 
    ACC = (move to) Accumulator
        Move a value into Accumulator. If the 32th bit is active, will take the value from the given Address, else, will store a direct value.
        But if the 32th bit is active, and no Address is given, it will use the value from the Address, like a pointer.
        Ex1: Store the value 0x000010 into the Accumulator
            ACC #0x000010
        Ex2: Store the value of the Address 0x123321 into the Accumulator
            ACC 0x123321
        Ex3: Store the content of the Address given by the Accumulator into the Accumulator
            Accumulator holds 0x00001234
            Address 0x001234 holds 0xffffaaaa
            ACC 0x000000
            Now Accumulator holds 0xffffaaaa

    STO = Store
        Store the current value of the Accumulator on the given Address. The 32th bit doesn't change the functionality.
        Ex1: Store the value into the Address 0x809010
            STO #0x809010 (or 0x809010)

    ERS = Erase
        Clears the selected Address (with zeroes). The same as "ACC #0x000000; STO Y", without messing the current value of Accumulator.
        The 32th bit doesn't change the functionality.
        Ex1: Erase the Address 0x300020
            ERS #0x300020 (or 0x300020)

    SWP = Swap the values of Accumulator with the chosen Address. The 32th bit doesn't change the functionality.
        Ex1: Accumulator holds value "100"
        The Address 0x000030 holds value "359"
        >SWP #0x000030  Now the Accumulator will hold the value "359", and the Address will hold the value "100".

    TXT = Outputs text in console            [CONS <= Y]
        Uses the simple 7-bit ASCII code (google it, uses the same scheme), but you can group them, and send up to four digits by time.
            (But to fit better on the 32bit system, the 7-bit ASCII is extended to 8-bit, with the last bit unused.)
        The writing on the console is made from left to right.
        You can use 64-bit to send the maximum of 4 characters by clock, using Address: 
            0x01 | TXT 0x00000f      = (0x9300000f) = 1001 0011 0000 0000 0000 0000 0000 1111
            ...
            0x0f | 0x4c6f6769                   = '0100 1100' '0110 1111' '0110 0111' '0110 1001' (the ' ' are separating the characters")
                                                          (L)         (o)         (g)         (i)
             Will output "Logi" to the console, as you can see in the circuit.
        Or you could just use just 32-bit of memory to send the maximum of 3 character per clock
                0x01 | TXT #0x4c6f67     = (0x134c6f67)  Will output "Log" to the console

        

    KEY = Stores the current character entered on keyboard   [ACC/MEM <= External Input #1]
        If no data is given with the instruction (=0x18000000), the ASCII will be saved on the Accumulator, else, 
        the ASCII will be saved on this Address. The 32th bit doesn't change the functionality.
        Ex1: Stores the current key on the Accumulator
            KEY #0x000000 (or 0x000000)
        Ex2: Stores the current key on the Address 0x123456
            KEY #0x123456 (or 0x123456)

    SCA = Store Current Address on the memory or in the address
        Ex:   This command is being readed on the memory Address 0x000030 (=0x30).
        Ex1: 0x30 | SCA #0x000000                     The Accumulator will now hold the value 0x30.
        Ex2: 0x30 | SCA  0x000070 (Or SCA 0x000070)   The Address 0x000070 will now hold the value 0x30.

    SRA = Set Relative Address
        This one is a little complex, but just think of instead using the 0x000000 Address as an start point,
         we changed it, so you can place a code anywhere in the memory and it would work without changing anything
         (just the SRA value, but you can create a small function to do it automatically. Tip: Use SCA).
        Ex1: Here we won't use the SRA command. Imagine we just executed the instruction in 0x30.
               0x40 | 0xdeadbeef   This address just hold this value.
               0x45 | 0xcafef00d   This address just hold this value.
               0x30 | ACC 0x000040 This will normally load the "0xdeadbeef" into the Accumulator.
        Ex2: Here we will use the SRA command. Imagine we executed the instructions 0x30 and 0x31.
               0x40 | 0xdeadbeef    This address just hold this value.
               0x45 | 0xcafef00d    This address just hold this value.
               0x30 | SRA #0x000005 This will make the address 0x000005 as an starting point.
               0x31 | ACC 0x000040  This is the same command from the Ex1, but it will load the "0xcafef00d" into the Accumulator,
            as you changed the starting point.
        As you can see, if you use the SRA command, all the Addresses you consult/change will be added from the SRA value.
        You can at anytime revert it to the normal by executing "SCA #0x000000").
        You can also use values stored on Memory. Imagine we started on address 0x09.
          Ex3: 0x07 | 0x00000003    This address just hold this value.
               0x09 | SRA 0x000007  As you see, no "#". So it will use an value stored in Memory. In the end, the Relative Address will now be 0x3.
       

    CLC = Clear ALU Flag                     [Not added yet.]
    CCF = Clear Comparative Flag (COMPFLAG)  [Not added yet.]    
   
    RND = Random
        This will generate a random 32 bits value, based on basic Logisim random number generator. If no data is given, the random number
        will be stored on accumulator, else, it will be stored on the memory. The 32th bit doesn't change the functionality.
        Ex1: Generate a random value to the Accumulator
            RND #0x000000 (or 0x000000)
        Ex2: Generate a random value to the Address 0x37
            RND #0x000047 (or 0x000047)
    
    PSH = Push
        This will store a 32 bits value into the LIFO (Last In First Out) memory. If the 32th bit is active, it will store the value
        stored in the given address, else, will store the direct value.
        Ex1: Push the value 1000h
            PSH #0x001000
        Ex2: Push the value stored on the Address 0x000011
            PSH 0x000011

    POP = Pop
        This will take out the last value stored on the LIFO (as the name says), and will store it on the Accumulator if no data is given, else
        will store on the given Address. The 32th bit doesn't change the functionality.
        Ex1: Pop into the Accumulator
            POP #0x000000
        Ex2: Pop into the Address 0x947203
            POP #0x947203 (or 0x947203)

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   9.2  Conditional
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 
 COMPFLAG = Comparative Flag
        
    CMP = Compare accumulator and value                    [COMPFLAG = "<, =, >" = "1, 2, 4]
        Attention: the focus is the value at Acc, ex:
        ACC #0x000008 -> Acc value is now 8.
        CMP #0x000002 -> Compare with the number 2.
        This will result in ">", COMPFLAG 4. Number 8 is bigger than number 2. Be careful.

    JMP = Jump to Address                                   [ADDRESS <= Y]
        Ex1: JMP #0x000050 -> will jump to the address 0x000050
        Ex2: JMP 0x000060 -> will read value from the address 0x000060 and jump to that value. In this case, will jump to 0x0000ff.
            0x000060 = #0x0000ff

    JZ  = Jump to adress if accumulator is 0                [ADDRESS = Y if X == 0]
    JNZ = Jump to adress if accumulator is not 0            [ADDRESS = Y if X !== 0]
    JC  = Jump to adress if ALU Flag is 1                   [ADDRESS <= Y]
    JNC = Jump to adress if ALU Flag is 0                   [ADDRESS <= Y]
    JL  = Jump to adress if COMPFLAG is less than           [ADDRESS <= Y if COMPFLAG == 1]
    JLE = Jump to adress if COMPFLAG is less than/equal     [ADDRESS <= Y if COMPFLAG == 1 | 2]
    JE  = Jump to adress if COMPFLAG is equal               [ADDRESS <= Y if COMPFLAG == 2]
    JGE = Jump to adress if COMPFLAG is greater than/equal  [ADDRESS <= Y if COMPFLAG == 2 | 4]
    JG  = Jump to adress if COMPFLAG is greater than        [ADDRESS <= Y if COMPFLAG == 4]
    JNE = Jump to adress if COMPFLAG is not equal           [ADDRESS <= Y if COMPFLAG not == 2]

    RET = Return to the Address it was before the JUMP was executed.
        Fact: Every JUMP command (JMP, JZ, JE, JC, etc but not the RET itself [should I change it?]) executed will save the Address where it was readen.
        This "RET" command, will jump back to the Address where the JUMP ocurred.
            Ex: This command is being readed on the memory Address 0x0000f5 (=0xf5).
                0xf5 | JMP 0x000078  The Address value 0xf5 will be saved in a specific register.
            If the RET command is given after this, will be executed a JUMP to the Address before the previous JUMP.
                0x...| RET #0x000000 There will be executed a JUMP to the Address 0xf5, and the JUMP register will hold the Address 0x....
            You can also tell if you want to Return to previous or nexts Address. (Signed operation)
                0x...| RET #0x000004 (+4 in decimal)Following the JMP example in the 0x75, this command will JUMP to the Address 0x79.
                0x...| RET #0xfffffb (-5 in decimal)Following the JMP example in the 0x75, this will JUMP to the Address 0x70


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   9.3   Mathematics (X=ACC, Y=Value)
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 The Value can be a direct value or indirect one.
    Ex: ADD #0x000008  -> Will add the value 8 to the accumulator.
    Ex: ADD  0x0000ff  -> Will add the value stored on the address 0x0000ff.
        
    ADD = Add accumulator + value             [X <= X+Y]
    SUB = Substract accumulator + value       [X <= X-Y]
    MUL = Multiply accumulator + value        [X <= X*Y]
    DIV = Divide accumulator + value          [X <= X/Y]
    NEG = Negate accumulator                  [X <= -X ]
        Note that this instruction doesn't use any additional information. Just do "NEG #0x000000".
        
    INC = Increase by 1 the data hold on the selected Address.
        Ex:   ACC #0x000005    Move the value "5" to the Accumulator.
        STO #0x000080    Will store the value on the Accumulator ("5") on the Address 0x000080.
        INC #0x000080    The address will now hold the value "6" (5+1)
        INC #0x000080    The address will now hold the value "7" (6+1)

    DEC = Decrease by 1 the data hold on the selected Address.
        Ex:   ACC #0x000005    Move the value "5" to the Accumulator.
        STO #0x000080    Will store the value on the Accumulator ("5") on the Address 0x000080.
        DEC #0x000080    The address will now hold the value "4" (5-1)
        DEC #0x000080    The address will now hold the value "3" (4-1)
        
    UCM = Unsigned Compare
    
    SCM = Signed Compare
     
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   9.4  Logical
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    AND = These ones are self explaining, logical operations.
    OR  = Logical OR.
    XOR = Logical Exclusive OR.
    NND = NAND, Logical NOT AND. Took a letter out to have just 3 letters.
    NOR = Logical NOT OR.
    XNR = XNOR, Logical Exclusive NOT OR. Took a letter out to have just 3 letters.
    NOT = Logical NOT. Only affects the Accumulator, and don't need more data than the last 8bits, the instruction itself.


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-   
   9.5  Shift / Rotate 
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    Shift instruction ex:
    SHL 0x000019 (=0x2c000019)
    9° to 27° bit not used
    First 5bits for distance, like on the ex:, 1 1001, the value held on the Accumulator will be shifted to left by 25 units.
    
    SHL = Shift Accumulator value left        [X << Y (5bits)]
    SHR = Shift Accumulator value right       [X >> Y (5bits)]
    ROL = Rotate Accumulator value left       [X << Y (5bits)]
    ROR = Rotate Accumulator value right      [X << Y (5bits)]



-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
A.                          Instruction Set List
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 A quick reference guide. Compact, simple, fast. Everything you need is in here.

    The instructions are ordered by crescent order (the same way visible on Instructions sub-circuit).
    If any of these doesn't work properly, contact me to fix it.
    The X in the Binary means "Don't-Care" (https://en.wikipedia.org/wiki/Don%27t-care_term), it will not change
        the instruction functionality. However, to don't make confusions, in the list below it wont be listed the hexadecimal code
        for the indirect mode (X = 1). Do prefer the X = 0 alternative, as the X = 1 may be added in the future.
    The D in the Binary will usually stands for direct and indirect modes, in the Hexadecimal column, the "#" is Y = 0, and the 
        "A" is Y = 1. To know the differences between them, read the specific instruction information in the previous section.
    The "#" usually stands for the direct mode.
          Ex: ACC #0xbabaca, will store this value on the Accumulator.
        While the "A" (Address) usually stands for the indirect mode.
          Ex: ADD 0x000fff, will add the value stored in this address.


[Binary] [Name]    ---[Hexadecimal]---     [Quick description]
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   A.1  GENERAL
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 
X000 0000 NOP  <>  0x00 (#)               - No Operation. Nothing will happen.
D000 0001 ACC  <>  0x01 (#) - 0x81 (A)    - Move to Accumulator
X000 0010 STO  <>  0x02 (#)               - Store
X000 0011 ERS  <>  0x03 (#)               - Erase
X000 0100 SWP  <>  0x04 (#)               - Swap


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   A.2  JUMPS
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

JPA
X000 0111 CAL  <>  0x07 (#)               - Call

X000 1000 JMP  <>  0x08 (#) - 0x88 (A)    - Jump
X000 1001 JZ   <>  0x09 (#) - 0x89 (A)    - Jump if Zero
X000 1010 JNZ  <>  0x0A (#) - 0x8A (A)    - Jump if Not Zero
X000 1011 JC   <>  0x0B (#) - 0x8B (A)    - Jump if Carry flag
X000 1100 JNC  <>  0x0C (#) - 0x8C (A)    - Jump if Not Carry flag
X000 1101 JA   <>  0x0D (#) - 0x8D (A)    - Jump if Above            (Unsigned)
X000 1110 JAE  <>  0x0E (#) - 0x8E (A)    - Jump if Above or Greater (Unsigned)
X000 1111 JG   <>  0x0F (#) - 0x8F (A)    - Jump if Greater          (Signed)
X001 0000 JGE  <>  0x10 (#) - 0x90 (A)    - Jump if Greater or Equal (Signed)
X001 0001 JE   <>  0x11 (#) - 0x91 (A)    - Jump if Equal
X001 0010 JNE  <>  0x12 (#) - 0x92 (A)    - Jump if Not Equal
X001 0011 JL   <>  0x13 (#) - 0x93 (A)    - Jump if Below            (Unsigned)
X001 0100 JLE  <>  0x14 (#) - 0x94 (A)    - Jump if Below or Equal   (Unsigned)
X001 0101 JL   <>  0x15 (#) - 0x95 (A)    - Jump if Less             (Signed)
X001 0110 JLE  <>  0x16 (#) - 0x96 (A)    - Jump if Less or Equal    (Signed)
X001 0111 RESERVED 0x17 (#) - 0x97 (A)
X001 1000 RESERVED 0x18 (#) - 0x98 (A)
X001 1001 RESERVED 0x19 (#) - 0x99 (A)
X001 1010 RESERVED 0x1A (#) - 0x9A (A)

X001 1011 RET  <>  0x1B (#) - 0x9B (A)    - Return to Call command origin


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   A.3  GENERAL2
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

X001 1100 INC  <>  0x1C (#)               - Increase (+=1) the data on Address
X001 1101 DEC  <>  0x1D (#)               - Decrease (-=1) the data on Address

X001 1110 SCA  <>  0x1E (#)               - Store Current Address
D001 1111 SRA  <>  0x1F (#) - 0x9F (A)    - Set Relative Address
X010 0000 RND  <>  0x40 (#)               - Random
D010 0001 PSH  <>  0x41 (#) - 0xC1 (A)    - Push
X010 0010 POP  <>  0x42 (#)               - Pop

D001 1110 TXT  <>  0x43 (#) - 0xC3 (A)    - Outputs text to console (External Output 1)
D001 0101 ???  <>  0x44 (#) - 0xC4 (A)    - External Output 2 - to be added
D001 0110 ???  <>  0x45 (#) - 0xC5 (A)    - External Output 3 - to be added
D001 0110 ???  <>  0x46 (#) - 0xC6 (A)    - External Output 3 - to be added

X001 1000 KEY  <>  0x47 (#)               - Store the ASCII entered (External Input 1)
X001 1001 ???  <>  0x48 (#)               - External Input 2 - to be added
X001 1010 JOY  <>  0x49 (#)               - Store the Joystick data (External Input 3)
X001 1011 ???  <>  0x4A (#)




#######X010 0001 BCD  <>  0x41 (#) - 0xC1 (A)    - Bin to Bcd decoder


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
   A.4  ARITHMETICH LOGIC UNIT (ALU)
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

D010 0001 ADD  <>  0x21 (#) - 0xA1 (A)    - Add
D010 0010 SUB  <>  0x22 (#) - 0xA2 (A)    - Substract
D010 0011 MUL  <>  0x23 (#) - 0xA3 (A)    - Multiply
D010 0100 DIV  <>  0x24 (#) - 0xA4 (A)    - Divide

D010 0101 CMP  <>  0x25 (#) - 0xA5 (A)    - Compare
D010 0110 RESERVED  <>  0x26 (#) - 0xA6 (A)    - RESERVED

D010 0111 AND  <>  0x27 (#) - 0xA7 (A)    - And Logic
D010 1000 OR   <>  0x28 (#) - 0xA8 (A)    - Or Logic
D010 1001 XOR  <>  0x29 (#) - 0xA9 (A)    - Xor Logic
D010 1010 NND  <>  0x2A (#) - 0xAA (A)    - Nand Logic
D010 1011 NOR  <>  0x2B (#) - 0xAB (A)    - Nor Logic
D010 1100 XNR  <>  0x2C (#) - 0xAC (A)    - Xnor Logic

D010 1101 SHL  <>  0x2D (#) - 0xAD (A)    - Shift Left
D010 1110 SHR  <>  0x2E (#) - 0xAE (A)    - Shift Right
D010 1111 ROL  <>  0x2F (#) - 0xAF (A)    - Roll Left
D011 0000 ROR  <>  0x30 (#) - 0xB0 (A)    - Roll Right

[D011 0001 ~ ?011 1101] Not used yet, feel free to add and share new instructions in this interval (floating points would be awesome)

X011 1110 NOT  <>  0x2A (#)               - Not
X011 1111 NEG  <>  0x2B (#)               - Negate



-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
B.                Credits, special thanks and contact
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    Special thanks to:
        AltruismAndCake - Reddit
        armorall171     - Reddit

    By Henrique Bruno Fantauzzi de Almeida, Rio de Janeiro - RJ, Brazil.
        henrique271197@gmail.com
        SrBrahma (Reddit), the subreddit is: https:www.reddit.com/r/logisim/
        Main post: https:redd.it/47lypv

Please, contact me if you share or modify it. I will be happy to know.


+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+#+
